use std::collections::HashMap;
use std::convert::TryInto;

use cosmwasm_std::{Order, KV};
use cosmwasm_vm::{BackendError, BackendResult, GasInfo, Storage};

use crate::db::DB;
use crate::error::GoResult;
use crate::iterator::GoIter;
use crate::memory::Buffer;

pub struct GoStorage {
    db: DB,
    iterators: HashMap<u32, GoIter>,
}

impl GoStorage {
    pub fn new(db: DB) -> Self {
        GoStorage {
            db,
            iterators: HashMap::new(),
        }
    }
}

impl Storage for GoStorage {
    fn get(&self, key: &[u8]) -> BackendResult<Option<Vec<u8>>> {
        let key_buf = Buffer::from_vec(key.to_vec());
        let mut result_buf = Buffer::default();
        let mut err = Buffer::default();
        let mut used_gas = 0_u64;
        let go_result: GoResult = (self.db.vtable.read_db)(
            self.db.state,
            self.db.gas_meter,
            &mut used_gas as *mut u64,
            key_buf,
            &mut result_buf as *mut Buffer,
            &mut err as *mut Buffer,
        )
        .into();
        let gas_info = GasInfo::with_externally_used(used_gas);
        let _key = unsafe { key_buf.consume() };

        // return complete error message (reading from buffer for GoResult::Other)
        let default = || {
            format!(
                "Failed to read a key in the db: {}",
                String::from_utf8_lossy(key)
            )
        };
        unsafe {
            if let Err(err) = go_result.into_ffi_result(err, default) {
                return (Err(err), gas_info);
            }
        }

        // We initialize `result_buf` with a null pointer. If it is not null, that means
        // it was initialized by the go code, with values generated by `memory::allocate_rust`.
        let value = if result_buf.ptr.is_null() {
            None
        } else {
            Some(unsafe { result_buf.consume() })
        };
        (Ok(value), gas_info)
    }

    fn scan(
        &mut self,
        start: Option<&[u8]>,
        end: Option<&[u8]>,
        order: Order,
    ) -> BackendResult<u32> {
        // returns nul pointer in Buffer in none, otherwise proper buffer
        let start_buf = start
            .map(|s| Buffer::from_vec(s.to_vec()))
            .unwrap_or_default();
        let end_buf = end
            .map(|e| Buffer::from_vec(e.to_vec()))
            .unwrap_or_default();
        let mut err = Buffer::default();
        let mut iter = GoIter::new(self.db.gas_meter);
        let mut used_gas = 0_u64;
        let go_result: GoResult = (self.db.vtable.scan_db)(
            self.db.state,
            self.db.gas_meter,
            &mut used_gas as *mut u64,
            start_buf,
            end_buf,
            order.into(),
            &mut iter as *mut GoIter,
            &mut err as *mut Buffer,
        )
        .into();
        let gas_info = GasInfo::with_externally_used(used_gas);
        let _start = unsafe { start_buf.consume() };
        let _end = unsafe { end_buf.consume() };

        // return complete error message (reading from buffer for GoResult::Other)
        let default = || {
            format!(
                "Failed to read the next key between {:?} and {:?}",
                start.map(String::from_utf8_lossy),
                end.map(String::from_utf8_lossy),
            )
        };
        unsafe {
            if let Err(err) = go_result.into_ffi_result(err, default) {
                return (Err(err), gas_info);
            }
        }

        let next_id: u32 = self
            .iterators
            .len()
            .try_into()
            .expect("Iterator count exceeded uint32 range. This is a bug.");
        self.iterators.insert(next_id, iter); // This moves iter. Is this okay?
        (Ok(next_id), gas_info)
    }

    fn next(&mut self, iterator_id: u32) -> BackendResult<Option<KV>> {
        let iterator = match self.iterators.get_mut(&iterator_id) {
            Some(i) => i,
            None => {
                return (
                    Err(BackendError::iterator_does_not_exist(iterator_id)),
                    GasInfo::free(),
                )
            }
        };
        iterator.next()
    }

    fn set(&mut self, key: &[u8], value: &[u8]) -> BackendResult<()> {
        let key_buf = Buffer::from_vec(key.to_vec());
        let value_buf = Buffer::from_vec(value.to_vec());
        let mut err = Buffer::default();
        let mut used_gas = 0_u64;
        let go_result: GoResult = (self.db.vtable.write_db)(
            self.db.state,
            self.db.gas_meter,
            &mut used_gas as *mut u64,
            key_buf,
            value_buf,
            &mut err as *mut Buffer,
        )
        .into();
        let gas_info = GasInfo::with_externally_used(used_gas);
        let _key = unsafe { key_buf.consume() };
        let _value = unsafe { value_buf.consume() };
        // return complete error message (reading from buffer for GoResult::Other)
        let default = || {
            format!(
                "Failed to set a key in the db: {}",
                String::from_utf8_lossy(key),
            )
        };
        unsafe {
            if let Err(err) = go_result.into_ffi_result(err, default) {
                return (Err(err), gas_info);
            }
        }
        (Ok(()), gas_info)
    }

    fn remove(&mut self, key: &[u8]) -> BackendResult<()> {
        let key_buf = Buffer::from_vec(key.to_vec());
        let mut err = Buffer::default();
        let mut used_gas = 0_u64;
        let go_result: GoResult = (self.db.vtable.remove_db)(
            self.db.state,
            self.db.gas_meter,
            &mut used_gas as *mut u64,
            key_buf,
            &mut err as *mut Buffer,
        )
        .into();
        let gas_info = GasInfo::with_externally_used(used_gas);
        let _key = unsafe { key_buf.consume() };
        let default = || {
            format!(
                "Failed to delete a key in the db: {}",
                String::from_utf8_lossy(key),
            )
        };
        unsafe {
            if let Err(err) = go_result.into_ffi_result(err, default) {
                return (Err(err), gas_info);
            }
        }
        (Ok(()), gas_info)
    }
}
